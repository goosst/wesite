<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Goosst blog</title>
		<link>http://users.telenet.be/goosst/posts/</link>
		<description>Recent content in Posts on Goosst blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 22 Dec 2019 00:00:00 +0000</lastBuildDate>
		<atom:link href="http://users.telenet.be/goosst/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Heating control from Android</title>
			<link>http://users.telenet.be/goosst/posts/hass_tor_macro/</link>
			<pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/hass_tor_macro/</guid>
			<description>Intro This is the continuation of HomeAssistant Tor. Here we&amp;rsquo;ll create a macro to automatically turn our heating on/off from an Android phone. The end result is something which only requires two / three pushes on a button on your android phone to turn on my heating. It works when being connected to a mobile network as well as a wifi network.
Method and tools  Macrodroid: Android app used for creating the macro.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>This is the continuation of <a href="http://users.telenet.be/goosst/posts/hass_tor/">HomeAssistant Tor</a>. Here we&rsquo;ll create a macro to automatically turn our heating on/off from an Android phone. The end result is something which only requires two / three pushes on a button on your android phone to turn on my heating.
It works when being connected to a mobile network as well as a wifi network.</p>

<h1 id="method-and-tools">Method and tools</h1>

<ul>
<li>Macrodroid: Android app used for creating the macro. It&rsquo;s free and can do everything we need.</li>
<li>Curl commands will be created making use of the <a href="https://developers.home-assistant.io/docs/en/external_api_rest.html">REST API from home assistant</a></li>
<li>You need a long-lived access token from HomeAssistant. It can be obtained by browsing to <a href="http://ip_addr_hass:8123/profile">http://ip_addr_hass:8123/profile</a> and creating one.</li>
</ul>

<p>Additional tools to make debugging easier on your phone: Termux</p>

<h1 id="macro-creation">Macro creation</h1>

<h2 id="home-assistant">Home Assistant</h2>

<p>In <code>configuration.yaml</code>:
* an input_boolean with the name turn_heating_on is defined
* an automation is defined if we see a change from off to on in this variable, an action is defined that runs an automation to turn our heating on</p>

<pre><code>input_boolean:
  turn_heating_on:
    name: Heating Living Day
    initial: off
</code></pre>

<pre><code>automation turn_heating_on_living:
  - alias: 'turn heating living on'
    trigger:
      platform: state
      entity_id: input_boolean.turn_heating_on
      from: 'off'
      to: 'on'
    action:
      - service: shell_command.set_temp_high
        data:
          message: &quot;Turned living heating on&quot;
      - delay: '00:01:00'
      - service: shell_command.read_ebus
</code></pre>

<h2 id="shell-script">shell script</h2>

<ul>
<li>Open Macrodroid &ndash;&gt; Add macro</li>
<li>Add an &ldquo;action&rdquo; of the type &ldquo;Applications-Shell Script&rdquo;</li>

<li><p>Create a curl command to change the state of turn_heating_on to off or on</p>

<pre><code>curl  \
-X POST --socks5-hostname localhost:9150 http://xxxxx.onion/api/states/input_boolean.turn_heating_on \
-H &quot;Authorization: Bearer
here_is_your_very_long_lived_token&quot; \
-H &quot;Content-Type: application/json&quot; \
-d '{&quot;state&quot;: &quot;off&quot;}'
</code></pre>

<figure>
    <img src="/goosst/pictures/macrodroid_shellscript.png" width="200"/> <figcaption>
            <h4>Macrodroid shell script</h4>
        </figcaption>
</figure>
</li>

<li><p>Start Orbot / Tor</p></li>

<li><p>Test your shell script and play with the &ldquo;state&rdquo; attribute, you should see the turn_heating_on change accordingly (&ldquo;off&rdquo;/&ldquo;on&rdquo;)</p></li>
</ul>

<h2 id="incorporate-in-larger-macro">Incorporate in larger macro</h2>

<ul>
<li>Create a larger macro which starts and stops Orbot automatically.</li>
<li>Since my home automation assumes a change from &ldquo;off&rdquo; to &ldquo;on&rdquo;, the turn_heating_on will be first put &ldquo;off&rdquo; and then put to &ldquo;on&rdquo;
<figure>
    <img src="/goosst/pictures/macrodroid_macro.png" width="200"/> <figcaption>
            <h4>Macrodroid macro</h4>
        </figcaption>
</figure>
</li>
</ul>

<p>The end result is, I need two/three pushes on the screen to turn my heating on:
* First push: start the macro
* Second push: when the orbot screen launches, push the big onion to connect to the tor network
* Optional third push: when the orbot screen launches for the second time, disconnect from the tor network</p>
]]></content>
		</item>
		
		<item>
			<title>Heating automation - setup hardware and ebus</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_wemos_ebus/</link>
			<pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_wemos_ebus/</guid>
			<description>Intro In this part we&amp;rsquo;ll connect to the communication bus of the heater and read / write some parameters by manually commanding them via a raspberry pi (in general, the instructions below work with any computer using debian/ubuntu).
Hardware Ebus adapter We need an ebus adapter for the raspberry to interface with our heater. I&amp;rsquo;m not going to write down all the details, since I can just refer to them:</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>In this part we&rsquo;ll connect to the communication bus of the heater and read / write some parameters by manually commanding them via a raspberry pi (in general, the instructions below work with any computer using debian/ubuntu).</p>

<h1 id="hardware">Hardware</h1>

<h2 id="ebus-adapter">Ebus adapter</h2>

<p>We need an ebus adapter for the raspberry to interface with our heater. I&rsquo;m not going to write down all the details, since I can just refer to them:</p>

<ul>
<li>Start reading here for more background: <a href="https://ebus.github.io/adapter/index.en.html">https://ebus.github.io/adapter/index.en.html</a></li>
<li>I&rsquo;m using the base board version 2.2, there might be better options to use directly with a raspberry pi. But when I ordered, it looked like the most flexible solution.</li>
<li>Adapter was ordered on the fhem forum. They will send you a pcb with a set of components, you have to solder yourself (or pay a bit extra): <a href="https://forum.fhem.de/index.php/topic,93190.msg857894.html#msg857894">https://forum.fhem.de/index.php/topic,93190.msg857894.html#msg857894</a>. If you&rsquo;ve read the first link you will also know there are commercial options in case you don&rsquo;t want this.</li>
<li>Put it in a box so there is no chance on touching electrical connections etc. .

<ul>
<li>You could consider placing the adapter inside the heater (plenty of space), I just didn&rsquo;t want to put custom electronics inside &hellip; .</li>
</ul></li>
</ul>

<figure>
    <img src="/goosst/pictures/ebus_adapter.jpg" width="250"/> <figcaption>
            <h4>ebus adapter v2.2</h4>
        </figcaption>
</figure>


<h2 id="attention">Attention!!</h2>

<p><strong><em>Connecting the ebus adapter over USB to your host, is not reliable over longer periods of time! I&rsquo;ve wasted way too much time with an unreliable home automation because of this. Connecting the adapter to a wemos, seems the more reliable route.</em></strong></p>

<p>If you&rsquo;re running on a single board computer:</p>

<ul>
<li>Please use a decent <a href="https://www.banggood.com/DC-5V-3_0A-EU-Power-Supply-Micro-USB-Adapter-Charger-For-Raspberry-Pi-3-Model-B-p-1079928.html?p=ET150713234951201708&amp;custlinkid=664887">power supply with at least 2/3A</a></li>
<li>Use a 32Gb size SD card (recommended by Home Assistant).</li>
</ul>

<h2 id="my-setup">My setup</h2>

<figure>
    <img src="/goosst/pictures/ebus_wemos.jpg" width="350"/> <figcaption>
            <h4>Wemos mini D1 and ebus adapter mounted on heater</h4>
        </figcaption>
</figure>


<ul>
<li><a href="https://www.banggood.com/Geekcreit-D1-Mini-V3_0_0-WIFI-Internet-Of-Things-Development-Board-Based-ESP8266-4MB-p-1264245.html?p=ET150713234951201708&amp;custlinkid=734961">Wemos mini D1</a> and ebus-adapter (without uart interface) are mounted against the heater by using velco strips</li>
<li>The white and purple wire are the ebus, they are connected inside the heater (ebus protocol has no polarity, so you can swap the wires)</li>
<li>ebus-adapter is connected through five wires as described <a href="https://ebus.github.io/adapter/images/wemos-wiring-v21.jpg">here</a></li>
</ul>

<h1 id="software">Software</h1>

<h2 id="software-wemos-d1-mini">Software Wemos D1 mini</h2>

<p>A special software is created by john30, the procedure to start using it is described on <a href="https://github.com/john30/ebusd-esp">his github page</a>.
There is not much too add here.</p>

<h2 id="ebusd">ebusd</h2>

<p>First install the ebus related software on your system running your home automation, see the ebus section in the <a href="/goosst/posts/hass_laptop/">installation guide</a>.</p>

<p>If this is done, adapt your ebus configuration to match your wemos settings:</p>

<ul>
<li>Check the settings in the interface of the wemos / ebus adapter, the ebusd device string is what you&rsquo;ll need in the next step.
<figure>
    <img src="/goosst/pictures/ebusd_adapter_wemos_sw.png" width="350"/> <figcaption>
            <h4>Interface when browsing to wemos D1 mini</h4>
        </figcaption>
</figure>
</li>

<li><p>adapt the ebus configuration on your host, as described in the following steps:</p>

<pre><code>cd /etc/default
sudo nano ebusd
</code></pre>

<p>Adapt the EBUSD_OPTS in the file, so you get something like the example below. (Pending your internet connection / hardware you might have to play with the latency parameters.)</p>

<pre><code># /etc/default/ebusd:
# config file for ebusd service.

# Options to pass to ebusd (run &quot;ebusd -?&quot; for more info):
#EBUSD_OPTS=&quot;--scanconfig&quot;
EBUSD_OPTS=&quot;-d 192.168.0.193:9999 -l /var/log/ebusd.log --scanconfig --latency=100000 --address=01&quot;
# MULTIPLE EBUSD INSTANCES WITH SYSV
# In order to run multiple ebusd instances on a SysV enabled system, simply
# define several EBUSD_OPTS with a unique suffix for each. Recommended is to
....
</code></pre></li>
</ul>

<p>Do a restart of the ebusd and check its status:</p>

<pre><code>sudo systemctl restart ebusd
sudo systemctl status ebusd
</code></pre>

<p>The output should look like this:</p>

<pre><code>● ebusd.service - ebusd, the daemon for communication with eBUS heating systems.
   Loaded: loaded (/lib/systemd/system/ebusd.service; enabled; vendor preset: enabled)
   Active: active (running) since Sat 2019-12-21 16:45:54 UTC; 56min ago
  Process: 3221 ExecStart=/usr/bin/ebusd $EBUSD_OPTS (code=exited, status=0/SUCCESS)
 Main PID: 3222 (ebusd)
    Tasks: 4 (limit: 4749)
   Memory: 1.5M
   CGroup: /system.slice/ebusd.service
           └─3222 /usr/bin/ebusd -d 192.168.0.193:9999 -l /var/log/ebusd.log --scanconfig --latency=100000 --address=01

Dec 21 16:45:54 tinkerboard systemd[1]: Starting ebusd, the daemon for communication with eBUS heating systems....
Dec 21 16:45:54 tinkerboard systemd[1]: Started ebusd, the daemon for communication with eBUS heating systems..
</code></pre>

<p>check if your heating system is identified by running <code>ebusctl info</code>:</p>

<pre><code>xxx@tinkerboard:~$ ebusctl info
version: ebusd 3.4.v3.3-51-g57eae05
update check: revision v3.4 available
signal: acquired
symbol rate: 42
max symbol rate: 102
min arbitration micros: 20
max arbitration micros: 177
min symbol latency: 6
max symbol latency: 80
reconnects: 0
masters: 3
messages: 345
conditional: 2
poll: 0
update: 9
address 01: master #6, ebusd
address 03: master #11
address 06: slave #6, ebusd
address 08: slave #11, scanned &quot;MF=Vaillant;ID=BAI00;SW=0202;HW=9602&quot;, loaded &quot;vaillant/bai.0010015600.inc&quot; ([HW=9602]), &quot;vaillant/08.bai.csv&quot;
address 10: master #2
address 15: slave #2, scanned &quot;MF=Vaillant;ID=F3700;SW=0114;HW=6102&quot;, loaded &quot;vaillant/15.f37.csv&quot;
</code></pre>

<p>Query some commands to see if everything is working as expected.</p>

<pre><code>xxx@tinkerboard:~$ ebusctl read RoomTemp
21.00;ok

xxx@tinkerboard:~$ ebusctl read Hc1DayTemp
21.0
</code></pre>

<h2 id="debugging">Debugging</h2>

<p>Useful commands to debug can be <code>tail -30 /var/log/ebusd.log</code>, this to see what ebus has been written to the log file configured in EBUSD_OPTS.</p>
]]></content>
		</item>
		
		<item>
			<title>Remote access home assistant</title>
			<link>http://users.telenet.be/goosst/posts/hass_tor/</link>
			<pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/hass_tor/</guid>
			<description>Intro Don&amp;rsquo;t we all want to monitor our home remotely (i.e. when not connected to our local network), turn on the heating on or off if we change our plans, check if everything is going well with our created home automation, etc. Of course we want to do this in a secure way that has limited chance of being hacked.
In this section we&amp;rsquo;ll use tor to access home assistant remotely and connect to it from our mobile phone (through mobile internet).</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>Don&rsquo;t we all want to monitor our home remotely (i.e. when not connected to our local network), turn on the heating on or off if we change our plans, check if everything is going well with our created home automation, etc.
Of course we want to do this in a secure way that has limited chance of being hacked.</p>

<p>In this section we&rsquo;ll use tor to access home assistant remotely and connect to it from our mobile phone (through mobile internet).
Read more about <a href="https://2019.www.torproject.org/docs/onion-services">Tor Hidden Services</a>.</p>

<h1 id="installation">Installation</h1>

<p>I&rsquo;m using a debian based system with home assistant running in a virtual (python) environment, as described <a href="http://users.telenet.be/goosst/posts/hass_laptop/">here</a>.</p>

<p>The documentation to setup tor is here: <a href="https://www.home-assistant.io/docs/ecosystem/tor">homeassistant tor</a>.
However, for debian 10 (buster), this isn&rsquo;t entirely correct anymore.
The &lsquo;HiddenServiceVersion 2&rsquo;, needs to be added to the torrc configration. All the other steps are still relevant.</p>

<p>torrc:</p>

<pre><code>HiddenServiceDir /var/lib/tor/homeassistant
HiddenServicePort 80 127.0.0.1:8123
HiddenServiceVersion 2
HiddenServiceAuthorizeClient stealth haremote1
</code></pre>

<h1 id="accessing-from-android-phone">Accessing from Android phone</h1>

<p>As described in <a href="https://www.home-assistant.io/docs/ecosystem/tor">homeassistant tor</a>, one need to install Orbot and Orfox (Tor browser).</p>

<h2 id="configuring-orbot">Configuring Orbot</h2>

<ul>
<li>Use the result obtained by executing <code>$ sudo more /var/lib/tor/homeassistant/hostname</code>, you will obtain something like <code>xxxxx.onion xx....xx</code>.</li>
<li>Edit the torrc file in Orbot &ndash;&gt; Settings &ndash;&gt; Torrc Custom Config. Fill in: <code>HidServAuth xxxxx.onion xx....xx</code></li>
<li>One additional step I had to, is to go to Orbot &ndash;&gt; Settings &ndash;&gt; Tor SOCKS and add port 9150. This to avoid getting a refused connection because of proxy servers.</li>
</ul>

<h1 id="home-assistant">Home Assistant</h1>

<p>The <code>configuration.yaml</code> file should have <code>type: homeassistant</code> to be able to access it remotely.
In my case when connected from the local internet (not through tor), I&rsquo;m automatically logged in.</p>

<pre><code>auth_providers:
  - type: trusted_networks
    trusted_networks:
      - 192.168.0.0/24
    allow_bypass_login: true
  - type: homeassistant
</code></pre>

<h1 id="usage">Usage</h1>

<h2 id="orfox-tor-browser">Orfox / Tor Browser</h2>

<ul>
<li>Start up Orbot (by pressing Start)</li>
<li>If successful, start up the Tor Browser and browse to your xxxxx.onion address. You should see your homeassistant login screen.</li>
<li>Create a bookmark with your .onion address. It&rsquo;s hard to know it by hard :).</li>
<li>click &ldquo;Home Assistant Local&rdquo;</li>
<li>type in your home assistant username and password</li>
<li>and you have your usual interface screen :)</li>
</ul>

<h2 id="create-a-macro">Create a macro</h2>

<p>Of course we are all lazy and don&rsquo;t want to start up Orbot, launch the browser, login to homeassistant, and change our settings.
Here is an example on how to create a macro on an android phone to turn on your heating: <a href="http://users.telenet.be/goosst/posts/hass_tor_macro/">link</a>.</p>
]]></content>
		</item>
		
		<item>
			<title>Setup debian system</title>
			<link>http://users.telenet.be/goosst/posts/hass_laptop/</link>
			<pubDate>Sat, 02 Nov 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/hass_laptop/</guid>
			<description>Intro This page is mainly to document the steps starting from a fresh linux install and setting up homeassistant and ebusd.
It starts with a fresh install of the debian based crunchbangplusplus, here installed on an (old) laptop with i386 processor. The same method has worked on other debian based systems (tested on armbian running on a singleboard computer). It is assumed the debian based distro is based on debian Buster.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>This page is mainly to document the steps starting from a fresh linux install and setting up homeassistant and ebusd.</p>

<p>It starts with a fresh install of the debian based <a href="https://www.crunchbangplusplus.org/">crunchbangplusplus</a>, here installed on an (old) laptop with i386 processor.
The same method has worked on other debian based systems (tested on armbian running on a singleboard computer).
It is assumed the debian based distro is based on debian Buster.
Quite some additional python and other packages are specific for my installation, they can be left out to suit your needs.</p>

<h1 id="remote-access">Remote access</h1>

<p>To make life easy and not be close to your machine running home assistant:</p>

<ul>
<li>ssh into the remote machine</li>
<li><code>sudo apt-get install tmux</code></li>
<li>start tmux by typing tmux</li>
<li>execute your commands in the started tmux session</li>
<li>leave/detach the tmux session by typing Ctrl+b and then d</li>
<li>If you connect again after being disconnected, type <code>tmux attach</code></li>
</ul>

<h1 id="install-home-assistant">Install home assistant</h1>

<p>This one mainly follows the steps outlined on the home assistant website to install hass in a virtual environment.</p>

<p>First prepare the list of repositories in crunchbangplusplus:
Add a line to your /etc/apt/sources.list: <code>deb http://ftp.de.debian.org/debian buster main</code></p>

<pre><code>sudo apt-get update
sudo apt-get upgrade
sudo apt-get install python3 python3-dev python3-venv python3-pip libffi-dev libssl-dev build-essential
sudo useradd -rm homeassistant
cd /srv
sudo mkdir homeassistant
sudo chown homeassistant:homeassistant homeassistant
sudo -u homeassistant -H -s
cd /srv/homeassistant
python3 -m venv .
source bin/activate
python3 -m pip install wheel
</code></pre>

<p>Install the development version of home assistant (or the stable of course):</p>

<pre><code>exit
sudo -u homeassistant -H -s
source /srv/homeassistant/bin/activate
pip3 install --pre --upgrade homeassistant
exit
</code></pre>

<p>Due to some specific installation issues with the 0.100 version, this one had to be installed manually: <code>https://pypi.org/project/home-assistant-frontend/</code></p>

<p>additional python packages</p>

<pre><code>sudo apt-get install libfreetype6-dev pkg-config libjpeg-dev imagemagick mosquitto mosquitto-clients
sudo -u homeassistant -H -s
source /srv/homeassistant/bin/activate
pip3 install ilock requests datetime numpy pytz matplotlib pillow pyunsplash
exit
</code></pre>

<h1 id="install-ebusd">Install ebusd</h1>

<p>select the correct computer-architecture:</p>

<pre><code> wget -O - https://raw.githubusercontent.com/john30/ebusd-debian/master/ebusd.gpg.key|sudo apt-key add -
 dpkg --print-architecture
 sudo wget -O /etc/apt/sources.list.d/ebusd.list https://raw.githubusercontent.com/john30/ebusd-debian/master/ebusd-i386-nomqtt.list
</code></pre>

<pre><code>sudo apt-get update
sudo apt-get install ebusd
</code></pre>

<p>check status and let it start at boot</p>

<pre><code> sudo systemctl status ebusd
 sudo systemctl start ebusd
 sudo systemctl stop ebusd
</code></pre>

<p>start at bootup:</p>

<pre><code>  sudo systemctl enable ebusd
</code></pre>

<h1 id="launch-homeassistant">Launch homeassistant</h1>

<p>Launch home assistant:</p>

<pre><code>sudo -u homeassistant -H -s
source /srv/homeassistant/bin/activate
hass
</code></pre>

<p>Check if any error messages pop up in the command window. If so, try to resolve them.
Brows to <a href="http://ip_address:8123">http://ip_address:8123</a>, to see if you can access. Setup an account.</p>

<h2 id="folder-settings">Folder settings</h2>

<p>Exit from the virtual environment to set some folder settings.
I copy my yaml and python files through FileZilla, which requires to change the read/write settings.
Maybe there are other solutions, but I don&rsquo;t know them.</p>

<pre><code>sudo mkdir /home/homeassistant/.homeassistant/www
sudo chmod -R 777 /home/homeassistant/.homeassistant/
</code></pre>

<p>copy files with Filezilla in the .homeassistant folder</p>

<p>run again <code>sudo chmod -R 777 /home/homeassistant/.homeassistant/</code></p>

<h1 id="static-ip-address">Static IP address</h1>

<p>Let the laptop bootup with a fixed ip address:
run <code>sudo nmtui</code>, change the following in <code>edit connection</code> (to have a fixed address: 192.168.0.205)
<figure>
    <img src="/goosst/pictures/nmtui.png" width="550"/> <figcaption>
            <h4>network settings</h4>
        </figcaption>
</figure>
</p>

<p>Most likely requires a reboot (and access to a display instead of ssh).</p>

<h1 id="result">Result</h1>

<figure>
    <img src="/goosst/pictures/hass_ui.png" width="750"/> <figcaption>
            <h4>hass interface</h4>
        </figcaption>
</figure>

]]></content>
		</item>
		
		<item>
			<title>e-paper - Extension to two displays</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_epaper_esp_twodisp/</link>
			<pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_epaper_esp_twodisp/</guid>
			<description>Intro In this part, the esp32 software will be extended to control two displays. The described solution mainly comes because of the great support from the creator of gxEPD2, so credits to him.
Hardware struggles The used 7.5 inch display, comes with an e-Paper Driver HAT. When connecting it as intended - 3.3V of this ESP32 connected to the 3.3 V of the e-paper HAT - it turns out very unreliable.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>In this part, the esp32 software will be extended to control two displays.
The described solution mainly comes because of the great support from the creator of <a href="https://github.com/ZinggJM/GxEPD2">gxEPD2</a>, so credits to him.</p>

<h1 id="hardware-struggles">Hardware struggles</h1>

<p>The used <a href="https://www.banggood.com/Waveshare-7_5-Inch-E-ink-Screen-Module-e-Paper-Display-SPI-Interface-For-Arduino-Raspberry-Pi-p-1365278.html?p=ET150713234951201708&amp;custlinkid=591953">7.5 inch display</a>, comes with an e-Paper Driver HAT.
When connecting it as intended - 3.3V of this <a href="https://www.banggood.com/LILYGO-TTGO-T-Energy-ESP32-8MByte-PSRAM-WiFi-bluetooth-Module-18650-Battery-ESP32-WROVER-IB-Development-Board-p-1427125.html?p=ET150713234951201708&amp;custlinkid=591947">ESP32</a> connected to the 3.3 V of the e-paper HAT - it turns out very unreliable.
It becomes more unreliable when combining more than one e-paper to the display (or it can be my cognitive bias).</p>

<p>The solution is to bypass the voltage converter and directly connect the 3.3V from the ESP32 according the picture below (see <a href="https://www.waveshare.com/w/upload/8/87/E-Paper-Driver-HAT-Schematic.pdf">scematics</a>):
<figure>
    <img src="/goosst/pictures/epaper_hat.png" width="300"/> <figcaption>
            <h4>Alternative 3.3V connection</h4>
        </figcaption>
</figure>
</p>

<h1 id="software-esp32">Software ESP32</h1>

<h2 id="spi">SPI</h2>

<p>One common SPI is used for both displays; the busy, reset and CS pin are separate pins for each display.
(Using two different SPI&rsquo;s for both displays, was too much work to make it work.)</p>

<pre><code>#define ENABLE_GxEPD2_GFX 1
#include &lt;GxEPD2_BW.h&gt;

//SPI pins, common for both displays
static const uint8_t EPD_DC   = 22; // to EPD DC
static const uint8_t EPD_SCK  = 18; // to EPD CLK
static const uint8_t EPD_MISO = 19; // Master-In Slave-Out not used, as no data from display
static const uint8_t EPD_MOSI = 23; // to EPD DIN

// display two:
static const uint8_t EPD_BUSY2 = 4;  // to EPD BUSY
static const uint8_t EPD_CS2   = 5;  // to EPD CS
static const uint8_t EPD_RST2  = 21; // to EPD RST
GxEPD2_BW&lt;GxEPD2_750, GxEPD2_750::HEIGHT&gt; display2(GxEPD2_750(/*CS=*/ EPD_CS2, /*DC=*/ EPD_DC, /*RST=*/ EPD_RST2, /*BUSY=*/ EPD_BUSY2));   // B/W display

//display one:
static const uint8_t EPD_BUSY1 = 25;  // to EPD BUSY
static const uint8_t EPD_RST1  = 34; // to EPD RST
static const uint8_t EPD_CS1   = 15;  // to EPD CS
GxEPD2_BW&lt;GxEPD2_750, GxEPD2_750::HEIGHT&gt; display1(GxEPD2_750(/*CS=*/ EPD_CS1, /*DC=*/ EPD_DC, /*RST=*/ EPD_RST1, /*BUSY=*/ EPD_BUSY1));   // B/W display

</code></pre>

<h2 id="displaying">Displaying</h2>

<p>Two images are downloaded now, one for each display: black1.bmp and black2.bmp</p>

<p>Full script is available on <a href="https://github.com/goosst/HomeAutomation/blob/master/esp32_epaper/bmp_http_twodisp.ino">github</a>.</p>

<h1 id="software-home-assistant">Software Home assistant</h1>

<p>Generate black1.bmp image</p>
]]></content>
		</item>
		
		<item>
			<title>e-paper - Home Assistant</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_epaper_hass/</link>
			<pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_epaper_hass/</guid>
			<description>Intro This is the part that will create the content out of home assistant and will get displayed on our e-paper. As an example I will display the expected commute time to work.
Python scripts being defined as a shell_command in configuration.yaml will be used. A simple automation to trigger the python script will be used.
Basis of script We want to make a plot that tells us the expected time of our commute with a graph of the last hour, to see how the time is trending.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>This is the part that will create the content out of home assistant and will get displayed on our e-paper.
As an example I will display the expected commute time to work.</p>

<p>Python scripts being defined as a shell_command in configuration.yaml will be used. A simple automation to trigger the python script will be used.</p>

<h1 id="basis-of-script">Basis of script</h1>

<p>We want to make a plot that tells us the expected time of our commute with a graph of the last hour, to see how the time is trending.</p>

<p>The component <a href="https://www.home-assistant.io/components/waze_travel_time/">waze travel time</a>, will be used to estimate our commuting time (with the name sensor.commute). Setting this up is not described in further detail.</p>

<pre><code>sensor:
- platform: waze_travel_time
  name: &quot;commute&quot;
  origin: zone.home
  destination: zone.work
</code></pre>

<p>You should create a <a href="https://www.home-assistant.io/components/http/#hosting-files">www</a> directory in your configuration folder</p>

<p>Note: To get the data out of home assistant, I&rsquo;ve explored a few routes. Using <a href="https://www.home-assistant.io/components/python_script/">hass-python script</a> for interfacing with home assistant, scripts that would operate on home-assistant_v2.db, &hellip; until I&rsquo;ve stumbled upon the <a href="https://developers.home-assistant.io/docs/en/external_api_rest.html#get-apihistory">Home Assistant: REST API</a>. After this discovery, I don&rsquo;t know why I should use anything else to capture data. Since this can be accessed from anywhere on the network (and makes debugging easy).</p>

<h2 id="rest-api">REST API</h2>

<p>The documentation from the REST API, describes how to obtain a long term token. This needs to be filled in the hearders file (the xxx location).</p>

<pre><code>
#location where figure will be stored
path=&quot;/home/homeassistant/.homeassistant/www&quot;
os.chdir(path)

# e-paper display size
width_displ=640
height_displ=384
dpi=100;

headers = {
    'Authorization': 'Bearer xxx,
    'content-type': 'application/json',
}
address_hass='192.168.0.205'
</code></pre>

<h2 id="getting-timezones">Getting timezones</h2>

<p>All data gets stored with UTC timestamps. We want to convert our data to the local timezone.</p>

<p>Obtaining the timezone can be done by requesting the <a href="https://developers.home-assistant.io/docs/en/external_api_rest.html#get-api-config">/api/config</a>:</p>

<pre><code># get timezone to convert to local time, since database attributes are in UTC time
url='http://'+address_hass+':8123/api/config'
response = get(url, headers=headers)
temp=response.text
readable_json=json.loads(temp)
time_zone=readable_json['time_zone']
tz = timezone(time_zone)
</code></pre>

<h2 id="get-sensor-history">Get sensor history</h2>

<p>Here the data from our sensor will be obtained, by default the history of 1 day is provided. The data will be stored in numpy arrays and will be immediately converted to the local timezone.</p>

<pre><code>entity_id='sensor.commute'

# this downloads history of the last day
url='http://'+address_hass+':8123/api/history/period'+'?filter_entity_id='+entity_id

response = get(url, headers=headers)
temp=response.text
temp=temp[1:len(temp)-1]
readable_json=json.loads(temp)

time_array= np.array([])
state_array=np.array([])
for i in readable_json:
    time_update=datetime.strptime(i['last_updated'],'%Y-%m-%dT%H:%M:%S.%f%z')
    time_array=np.append(time_array, time_update.astimezone(tz))
    state_array=np.append(state_array,float(i['state']))
</code></pre>

<h2 id="create-bitmap-file">Create bitmap file</h2>

<p>At last, a plot from the data within the last hour will be created,
the x-axis will be plotted containing hours and minutes</p>

<pre><code># only plot data from last hour
time_treshold=time_array[-1]-timedelta(hours=1)
idx=time_array&gt;time_treshold

last_info=readable_json[-1]
last_attr=last_info['attributes']

fig=plt.figure(num=None, figsize=(int(width_displ/dpi), int(height_displ/dpi)), dpi=dpi, facecolor='w', edgecolor='k')

plt.plot(time_array[idx],state_array[idx],linewidth=7.0,c='k')
plt.ylabel('Minutes',fontsize=20)
plt.xticks(fontsize=18)
plt.yticks(fontsize=18)
ax = plt.gca()
ax.yaxis.set_major_formatter(FormatStrFormatter('%.0f'))

plt.title('Commute: '+format(state_array[-1],'.0f')+' min'+'\n '+'Route: '+last_attr['route'],fontsize=28)

xformatter = DateFormatter('%H:%M')
plt.gcf().axes[0].xaxis.set_major_formatter(xformatter)
plt.gcf().autofmt_xdate()

fig.savefig('plot.png',bbox_inches='tight',dpi=dpi)
</code></pre>

<p>Example, generated figure:</p>

<figure>
    <img src="/goosst/pictures/commute_example.png" width="350"/> <figcaption>
            <h4>Example bitmap </h4>
        </figcaption>
</figure>


<h1 id="testing-the-python-script">Testing the python script</h1>

<p>ssh to the home assistant server (raspberry pi)</p>

<pre><code>sudo su -s /bin/bash homeassistant
cd /home/homeassistant/.homeassistant/python_scripts/
python3 db_plotter.py
</code></pre>

<p>As a next step we will add options to the python script, so we can command different options through automations in home assistant.</p>

<pre><code># check if passed options are valid
try:
    options, args = getopt.getopt(sys.argv[1:], 's:',['selection='])
    # print(options)
    # print(args)
except getopt.GetoptError:
    print(&quot;incorrect syntax&quot;)
    print(&quot;usage: python3 db_plotter.py -s &lt;value&gt;&quot;)
    print(&quot;default to option 1&quot;)
    display_option=1
    sys.exit(2)
for opt, value in options:
    if opt in ('-s','-S','--selection'):
        display_option=int(value)
        print(&quot;successful argument&quot;)
        print(display_option)
</code></pre>

<p>The whole script, created above will be moved to an if-else construction</p>

<pre><code>if display_option==2:
    entity_id='sensor.commute'
    ....
</code></pre>

<p>Now we need to test the script by running: <code>python3 db_plotter.py -s 2.0</code></p>

<h1 id="configuration-yaml">Configuration.yaml</h1>

<p>Define the script as a shell command with the option to give different arguments with it, contained in a dummy variable (dummy_epaper).</p>

<pre><code>shell_command:
  take_screenshot: 'python3 /home/homeassistant/.homeassistant/python_scripts/db_plotter.py -s {{ states.input_number.dummy_epaper.state }}'

input_number:
  dummy_epaper:
    name: dummy epaper
    initial: 2
    min: 1
    max: 3
    step: 1
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>e-paper - Display ESP32</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_epaper_esp/</link>
			<pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_epaper_esp/</guid>
			<description>Intro In this part, a figure, living on the Home Assistant server, will be displayed on a 7.5 inch e-paper using an ESP32-based board.
Used components: 7.5 inch e-paper from Waveshare with Driver HAT ESP32 based development board with battery holder Esp 32: pinout The SPI interface of the ESP32 will be used to control the display. The pins of SPI quickly get confusing:
 Names of the different interfaces of SPI aren&amp;rsquo;t very consistently used (MOSI, SPI D, SD0, SS, CS, SCK, CLK, SD1, &amp;hellip; ) + you have to pay attention to the difference between IO pins and GPIO pins in the ESP32 datasheet.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>In this part, a figure, living on the Home Assistant server, will be displayed on a 7.5 inch e-paper using an ESP32-based board.</p>

<h2 id="used-components">Used components:</h2>

<a target='_blank' href='https://www.banggood.com/Waveshare-7_5-Inch-E-ink-Screen-Module-e-Paper-Display-SPI-Interface-For-Arduino-Raspberry-Pi-p-1365278.html?p=ET150713234951201708&custlinkid=591953'><img src='https://imgaz.staticbg.com/images/oaupload/banggood/images/96/80/7005740a-3d5f-4246-b7cd-9a688c012370.JPG' alt='' width="400"><center>7.5 inch e-paper from Waveshare with Driver HAT</center></a>


<a target='_blank' href='https://www.banggood.com/LILYGO-TTGO-T-Energy-ESP32-8MByte-PSRAM-WiFi-bluetooth-Module-18650-Battery-ESP32-WROVER-IB-Development-Board-p-1427125.html?p=ET150713234951201708&custlinkid=591947'><img src='https://imgaz.staticbg.com/images/oaupload/ser1/banggood/images/AA/A0/5c61b05c-dbc2-4594-9a4b-8f7ee3870389.jpg' alt='' width="250"><center>ESP32 based development board with battery holder</center></a>


<h1 id="esp-32-pinout">Esp 32: pinout</h1>

<p>The SPI interface of the ESP32 will be used to control the display.
The pins of SPI quickly get confusing:</p>

<ul>
<li>Names of the different interfaces of SPI aren&rsquo;t very consistently used (MOSI, SPI D, SD0, SS, CS, SCK, CLK, SD1, &hellip; ) + you have to pay attention to the difference between IO pins and GPIO pins in the ESP32 datasheet.</li>
<li>The ports labeled on the ESP-board with clk, SD0, SD1, &hellip; are linked to an SPI bus. But one only used to flash the device, not used for communication with external devices &hellip; .</li>
</ul>

<p>In the <a href="https://www.espressif.com/sites/default/files/documentation/esp32-wrover_datasheet_en.pdf">ESP32-wrover datasheet</a>, it can be found two SPI busses are available for external communication: VSPI and HSPI.</p>

<p>Below, the overview is provided to which pins these two busses correspond with. The last column is mainly added to be able to check if custom esp32 boards (like this one) also respect the GPIO labels marked on the board. (The esp32 feet are still large enough to check with a multi-meter.)</p>

<table>
<thead>
<tr>
<th>VSPI</th>
<th>GPIO   (pin label)</th>
<th>Name ESP32-wrover chip</th>
<th>No.  ESP32 Chip</th>
</tr>
</thead>

<tbody>
<tr>
<td>MOSI</td>
<td>23</td>
<td>VSPI D</td>
<td>37</td>
</tr>

<tr>
<td>MISO</td>
<td>19</td>
<td>VSPI Q</td>
<td>31</td>
</tr>

<tr>
<td>SCK</td>
<td>18</td>
<td>VSPI CLK</td>
<td>30</td>
</tr>

<tr>
<td>SS</td>
<td>5</td>
<td>VSPI CS</td>
<td>29</td>
</tr>
</tbody>
</table>

<p>HSPI:</p>

<table>
<thead>
<tr>
<th>HSPI</th>
<th>GPIO   (pin number board)</th>
<th>Name ESP32-wrover chip</th>
<th>No.  ESP32 Chip</th>
</tr>
</thead>

<tbody>
<tr>
<td>MOSI</td>
<td>13</td>
<td>HSPI D</td>
<td>16</td>
</tr>

<tr>
<td>MISO</td>
<td>12</td>
<td>HSPI Q</td>
<td>14</td>
</tr>

<tr>
<td>SCK</td>
<td>14</td>
<td>HSPI CLK</td>
<td>13</td>
</tr>

<tr>
<td>SS</td>
<td>15</td>
<td>HSPI CS</td>
<td>23</td>
</tr>
</tbody>
</table>

<p>For the BUSY, reset and DC pin, any suitable DIO can be selected. This is how it looks in my configuration / script for VSPI:</p>

<pre><code>static const uint8_t EPD_BUSY = 4;  // to EPD BUSY
static const uint8_t EPD_CS   = 5;  // to EPD CS
static const uint8_t EPD_RST  = 21; // to EPD RST
static const uint8_t EPD_DC   = 22; // to EPD DC
static const uint8_t EPD_SCK  = 18; // to EPD CLK
static const uint8_t EPD_MISO = 19; // Master-In Slave-Out not used, as no data from display
static const uint8_t EPD_MOSI = 23; // to EPD DIN
</code></pre>

<h1 id="esp-32-the-code">Esp 32: the code</h1>

<p>The great <a href="https://github.com/ZinggJM/GxEPD2">GxEPD2 library</a> will be used for drawing on the e-paper display.</p>

<ul>
<li>A good example to verify if your pinout is correct and libraries are installed correctly, is to use this implementation: <a href="https://github.com/G6EJD/ESP32-e-Paper-Weather-Display">Weather display</a></li>
<li>For our purposes the default example in the library - GxEPD2_WiFi_Example.ino - will be modified to fit our purposes.
The main challenge was to make it download an image from a local website (home assistant at <a href="http://192.168.0.205:8123/local/black2.bmp">http://192.168.0.205:8123/local/black2.bmp</a> ).</li>
</ul>

<p>The resulting script can be found <a href="https://github.com/goosst/HomeAutomation/blob/master/esp32_epaper/">here</a>, if you want to test it out:</p>

<ul>
<li><p>A Credentials.h file is expected which contains your WiFi settings</p>

<pre><code>const char* ssid     = &quot;xxx&quot;;
const char* password = &quot;xxx&quot;;
</code></pre></li>

<li><p>You have to copy a small bitmap image (.bmp) in your xxx/www folder in home assistant (<a href="https://www.home-assistant.io/components/http/#hosting-files">Home Assistant: External files</a>), or generate content through scripts (<a href="/goosst/posts/homeautomation_epaper_hass/">Home assistant: content creation</a>)</p></li>

<li><p>Pay attention to set the SleepDuration, WakeupTime, SleepTime, &hellip; in the script when the system should remain awake</p></li>

<li><p>Of course, change 192.168.0.205:8123 to your own home assistant settings</p></li>
</ul>

<h1 id="others">Others</h1>

<p>if you want to play around with displaying any image, I use ImageMagick to convert images to bitmaps consisting of 3D arrays (and not 4D) with the command:</p>

<pre><code>convert plot.png -resize 640x384 -type GrayScale -depth 8 black2.bmp
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>e-paper - Display concept</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_epaper_gen/</link>
			<pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_epaper_gen/</guid>
			<description>Intro This part sketches the entire flow. I&amp;rsquo;ve changed my method a few times during the creation of this. Mainly because I just stumble upon things in the home assistant documentation, rather than actually finding something when I need it :).
Different steps   Sequence to get home assistant content on e-paper    Relevant references to documentation (I want to find it back myself ;):
 Home Assistant: External files Home Assistant: REST API  Remarks:</description>
			<content type="html"><![CDATA[

<h1 id="intro">Intro</h1>

<p>This part sketches the entire flow. I&rsquo;ve changed my method a few times during the creation of this. Mainly because I just stumble upon things in the home assistant documentation, rather than actually finding something when I need it :).</p>

<h1 id="different-steps">Different steps</h1>

<figure>
    <img src="/goosst/pictures/epaper_hass.png" width="350"/> <figcaption>
            <h4>Sequence to get home assistant content on e-paper </h4>
        </figcaption>
</figure>


<p>Relevant references to documentation (I want to find it back myself ;):</p>

<ul>
<li><a href="https://www.home-assistant.io/components/http/#hosting-files">Home Assistant: External files</a></li>
<li><a href="https://developers.home-assistant.io/docs/en/external_api_rest.html#get-apihistory">Home Assistant: REST API</a></li>
</ul>

<p>Remarks:</p>

<ul>
<li>I&rsquo;m using <a href="https://www.home-assistant.io/docs/installation/hassbian/installation/">hassbian</a> on a raspberry pi 3, I have not checked if anything should change when using hassio and other variants</li>
<li>the REST API, would allow to do everything on the esp32, but I didn&rsquo;t go that route &hellip; .</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>e-paper - Display Intro</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_epaper_intro/</link>
			<pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_epaper_intro/</guid>
			<description>Intro  E-paper display linked with Home Assistant   --   E-paper display linked with Home Assistant   I wanted a display which:
 does not consume (a lot of) electricity is linked with home-assistant, so I can get useful updates pending the moment of the day can display interesting photos, when I don&amp;rsquo;t want to know the status of my house / surroundings :) doesn&amp;rsquo;t cost an arm and a leg  The result of my tinkering can be seen in the picture above.</description>
			<content type="html"><![CDATA[

<h1 id="intro">Intro</h1>

<!-- <figure>
    <img src="/goosst/pictures/epaper_display.jpg" width="760"/> <figcaption>
            <h4>E-paper display linked with Home Assistant</h4>
        </figcaption>
</figure>
 -->

<figure>
    <img src="/goosst/pictures/epaper_display1.jpg" width="700"/> <figcaption>
            <h4>E-paper display linked with Home Assistant</h4>
        </figcaption>
</figure>


<p>I wanted a display which:</p>

<ul>
<li>does not consume (a lot of) electricity</li>
<li>is linked with home-assistant, so I can get useful updates pending the moment of the day</li>
<li>can display interesting photos, when I don&rsquo;t want to know the status of my house / surroundings :)</li>
<li>doesn&rsquo;t cost an arm and a leg</li>
</ul>

<p>The result of my tinkering can be seen in the picture above.</p>

<p>I&rsquo;ve used two 7.5 inch e-paper displays and incorporated them into a picture frame. The reason for two dislays is mainly because larger e-papers just become very expensive. Obviously you don&rsquo;t need two, if you don&rsquo;t want to&hellip; .</p>

<h1 id="concept">Concept</h1>

<p>In the following posts, the different parts of the display are explained in more detail:</p>

<ul>
<li><a href="/goosst/posts/homeautomation_epaper_gen/">General concept</a></li>
<li><a href="/goosst/posts/homeautomation_epaper_esp/">Control e-paper with ESP 32</a></li>
<li><a href="/goosst/posts/homeautomation_epaper_hass/">Home assistant: content creation</a></li>
</ul>

<p>All code is available at: <a href="https://github.com/goosst/HomeAutomation">github</a></p>

<h1 id="remarks-and-todo">Remarks and Todo</h1>

<ul>
<li>I should not have bought an ESP32 board including an 18650 battery: this types of batteries is barely available in Europe + if I want it battery operated I can just attach a powerbank, there is more than enough space in the picture frame.</li>
<li>Still need to get the second screen up and running (using the same ESP32 board)</li>
<li>add description of construction</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Heating automation - alarm</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_alarm/</link>
			<pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_alarm/</guid>
			<description>HAHAHUGOSHORTCODE-TOC0-HBHB  Intro I&amp;rsquo;ve let a relay install during yearly maintenance of my alarm, this allows me to tell me when the alarm is turned on or off. This makes life for presence detection significantly more simple :).
We&amp;rsquo;ll use MQTT to send status of alarm to Home Assistant.
Troubleshooting The connection of a Wemos D1 with Arduino IDE seems to be junk (the arduino IDE part). We need to use esptool instead pip3 install esptool.</description>
			<content type="html"><![CDATA[

<aside>
    HAHAHUGOSHORTCODE-TOC0-HBHB
</aside>

<h1 id="intro">Intro</h1>

<p>I&rsquo;ve let a relay install during yearly maintenance of my alarm, this allows me to tell me when the alarm is turned on or off. This makes life for presence detection significantly more simple :).</p>

<p>We&rsquo;ll use MQTT to send status of alarm to Home Assistant.</p>

<h2 id="troubleshooting">Troubleshooting</h2>

<p>The connection of a <a href="https://www.banggood.com/Geekcreit-D1-R2-V2_1_0-WiFi-Uno-Module-Based-ESP8266-Module-For-Arduino-Nodemcu-Compatible-p-1085610.html?p=ET150713234951201708&amp;custlinkid=664901">Wemos D1</a> with Arduino IDE seems to be junk (the arduino IDE part). We need to use esptool instead
<code>pip3 install esptool</code>.</p>

<p>structure to use:
<code>esptool --port &quot;{serial.port}&quot; --baud {upload.speed} write_flash 0x00000 &quot;{build.path}/{build.project_name}.bin</code></p>

<h2 id="used-script">Used script</h2>

<p><a href="https://github.com/goosst/HomeAutomation/blob/master/wemos/sketch/sketch.ino">Location</a>
Can be updated over the air (ota), so you only have to fysically connect it once (in theory at least, if everything uploads correctly)</p>
]]></content>
		</item>
		
		<item>
			<title>Heating automation - electric heater</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_el_heater/</link>
			<pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_el_heater/</guid>
			<description>Intro We&amp;rsquo;ll be using one of the sonoff devices to turn on/off a wall-plugged electric heater. These devices are pretty cheap but since we&amp;rsquo;ll be hacking into them, use at your own risk.
The sonoff S20 is more hackerfriendly compared to the S26 (from soldering standpoint). But once it&amp;rsquo;s done, the S26 is more compact and looks slick :). I&amp;rsquo;ve used both in the meantime (and I&amp;rsquo;m not a soldering guru by far).</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>We&rsquo;ll be using one of the sonoff devices to turn on/off a wall-plugged electric heater. These devices are pretty cheap but since we&rsquo;ll be hacking into them, use at your own risk.</p>

<p>The sonoff S20 is more hackerfriendly compared to the S26 (from soldering standpoint). But once it&rsquo;s done, the S26 is more compact and looks slick :). I&rsquo;ve used both in the meantime (and I&rsquo;m not a soldering guru by far).</p>

  <a target='_blank' href='https://www.banggood.com/SONOFF-S26-10A-AC90V-250V-Smart-WIFI-Socket-USUKAUEU-Wireless-Plug-Power-Sockets-p-1308841.html?p=ET150713234951201708&custlinkid=257729'><img src='https://imgaz.staticbg.com/images/oaupload/banggood/images/75/01/bf9b7b7d-80b4-4e18-a1c6-6db816225de5.jpg' alt='' width="200"><center>S26</center></a>
  <a target='_blank' href='https://www.banggood.com/SONOFF-S20-10A-2200W-Wifi-Wireless-Remote-Control-Socket-Smart-Timer-Plug-Smart-Home-Power-Socket-Support-Alexa-p-1142285.html?p=ET150713234951201708&custlinkid=257739'><img src='https://img.staticbg.com/images/oaupload/banggood/images/3E/30/4ca60816-90f6-401f-bdbc-4d41a4d01939.jpg' alt='' width="200"><center>S20</center></a>


<h2 id="concept">Concept</h2>

<ul>
<li>The sonoff devices will be flashed with the custom Tasmota firmware (cfr. the very complete documentation at <a href="https://github.com/arendst/Sonoff-Tasmota">https://github.com/arendst/Sonoff-Tasmota</a>).</li>
<li>There are enough sites out there explaining the flashing procedure (<a href="https://github.com/arendst/Tasmota/wiki/Sonoff-S26-Smart-Socket">https://github.com/arendst/Tasmota/wiki/Sonoff-S26-Smart-Socket</a> as starting point). I flash through the FTDI device below (can handle 3.3 and 5V based devices): <a target='_blank' href='https://www.banggood.com/FT232RL-FTDI-USB-To-TTL-Serial-Converter-Adapter-Module-For-Arduino-p-917226.html?p=ET150713234951201708&custlinkid=257737'><img src='https://img.staticbg.com/images/oaupload/banggood/images/4A/1F/72fb76d9-d3ad-45a4-9323-e9924a3d7805.jpg' alt='' width="150"></a>
</li>
<li>Once this is done, MQTT messages will be used to control and report the status through the interface of Home Assistant</li>
</ul>

<h2 id="configure-mqtt-tasmota">Configure MQTT Tasmota</h2>

<p>First, flash the Tasmota software.</p>

<p>Then browse to the ip-address of your sonoff device and click further to do some limited MQTT configuration. Here you can define the names / passwords / username of your MQTT topics (see screenshot below). The full name of the MQTT can be double checked in <a href="http://IP_ADDRESS_OF_YOUR_SONOFF/in">http://IP_ADDRESS_OF_YOUR_SONOFF/in</a>.</p>

<figure>
    <img src="/goosst/pictures/Tasmota.png" width="450"/> <figcaption>
            <h4>MQTT configuration in Tasmota</h4>
        </figcaption>
</figure>


<p>The MQTT methods in the Tasmota software are very well documented (a bit overwhelming at first):</p>

<ul>
<li>list of useful topics: <a href="https://github.com/arendst/Sonoff-Tasmota/wiki/Commands#mqtt">https://github.com/arendst/Sonoff-Tasmota/wiki/Commands#mqtt</a></li>
<li>general explanation: <a href="https://github.com/arendst/Sonoff-Tasmota/wiki/MQTT-Overview">https://github.com/arendst/Sonoff-Tasmota/wiki/MQTT-Overview</a></li>
</ul>

<p>Two MQTT topics will be used for this application:</p>

<ul>
<li>one to report the status</li>
<li>one to send the commands (this one doesn&rsquo;t need additional configuration)</li>
</ul>

<p>To monitor the status of the device, the tele-messages - continuously broadcasted by Tasmota - will be used. The update rate of the tele-message can be set with the TelePeriod command (see screenshot below).
<figure>
    <img src="/goosst/pictures/Tasmota_console.png" width="500"/> <figcaption>
            <h4>Configure update rate of the tele-message to 60 seconds</h4>
        </figcaption>
</figure>
</p>

<h2 id="home-assistant">Home assistant</h2>

<p>First check if the messages truly arrive on the host, by listening to them from the terminal on the host:</p>

<pre><code>$ mosquitto_sub -v -h localhost -t tele/sonoff/#
tele/sonoff/LWT Online
tele/sonoff/STATE {&quot;Time&quot;:&quot;2019-08-02T18:32:57&quot;,&quot;Uptime&quot;:&quot;0T00:33:19&quot;,&quot;Vcc&quot;:3.178,&quot;SleepMode&quot;:&quot;Dynamic&quot;,&quot;Sleep&quot;:250,&quot;LoadAvg&quot;:24,&quot;POWER&quot;:&quot;OFF&quot;,&quot;Wifi&quot;:{&quot;AP&quot;:1,&quot;SSId&quot;:&quot;*****&quot;,&quot;BSSId&quot;:&quot;*****&quot;,&quot;Channel&quot;:6,&quot;RSSI&quot;:44,&quot;LinkCount&quot;:1,&quot;Downtime&quot;:&quot;0T00:00:06&quot;}}
tele/sonoff/STATE {&quot;Time&quot;:&quot;2019-08-02T18:33:57&quot;,&quot;Uptime&quot;:&quot;0T00:34:19&quot;,&quot;Vcc&quot;:3.178,&quot;SleepMode&quot;:&quot;Dynamic&quot;,&quot;Sleep&quot;:250,&quot;LoadAvg&quot;:3,&quot;POWER&quot;:&quot;OFF&quot;,&quot;Wifi&quot;:{&quot;AP&quot;:1,&quot;SSId&quot;:&quot;*****&quot;,&quot;BSSId&quot;:&quot;*****&quot;,&quot;Channel&quot;:6,&quot;RSSI&quot;:44,&quot;LinkCount&quot;:1,&quot;Downtime&quot;:&quot;0T00:00:06&quot;}}
tele/sonoff/STATE {&quot;Time&quot;:&quot;2019-08-02T18:34:57&quot;,&quot;Uptime&quot;:&quot;0T00:35:19&quot;,&quot;Vcc&quot;:3.190,&quot;SleepMode&quot;:&quot;Dynamic&quot;,&quot;Sleep&quot;:250,&quot;LoadAvg&quot;:9,&quot;POWER&quot;:&quot;OFF&quot;,&quot;Wifi&quot;:{&quot;AP&quot;:1,&quot;SSId&quot;:&quot;*****&quot;,&quot;BSSId&quot;:&quot;*****&quot;,&quot;Channel&quot;:6,&quot;RSSI&quot;:42,&quot;LinkCount&quot;:1,&quot;Downtime&quot;:&quot;0T00:00:06&quot;}}

</code></pre>

<p>All arriving, all good :).</p>

<p>Now, define a binary sensor in <code>configuration.yaml</code> to monitor the on/off status of the device. Here the value_template needs to be used to filter the specific message we want (here on/off of the device).</p>

<pre><code>binary_sensor:
  - platform: mqtt
    name: &quot;heater status&quot;
    state_topic: 'tele/sonoff/STATE'
    value_template: &quot;{{value_json.POWER}}&quot;
</code></pre>

<p>To command the sonoff to turn on and off we&rsquo;ll define a switch. This one uses the cmnd features of Tasmota:</p>

<pre><code>switch:
  - platform: mqtt
    name: &quot;handdoekdroger control&quot;
    command_topic: cmnd/sonoff/Power1
    payload_on: &quot;ON&quot;
    payload_off: &quot;OFF&quot;

</code></pre>

<h2 id="ui">UI</h2>

<p>In <code>ui-lovelace.yaml</code>, the following is defined:</p>

<pre><code>      - type: entities
        title: bathroom
        entities:
          - binary_sensor.heater_status
          - switch.handdoekdroger_control
</code></pre>

<p>et voila, one can command and read the status of the sonoff device through Home Assitant:
(of course there is a delay of maximum 60s in the status reporting due to the usage of the tele-message.)</p>

<figure>
    <img src="/goosst/pictures/HA_sonoff.png" width="350"/> <figcaption>
            <h4>MQTT configuration in Tasmota</h4>
        </figcaption>
</figure>

]]></content>
		</item>
		
		<item>
			<title>Heating automation - device tracking</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_partiiii/</link>
			<pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_partiiii/</guid>
			<description>Intro In this part we&amp;rsquo;ll turn our heating off and on when we leave the house (by detecting presence of our mobile phone).
Concept We&amp;rsquo;ll be checking if the mac-address of our phone is on the wifi network. Based on this we&amp;rsquo;ll do a simple scheduling of our heating.
Home assistant No python scripts this time, only activity is done in Home Assistant.
Device tracking Example below will use the component device_tracker and the nmap program to scan the network.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>In this part we&rsquo;ll turn our heating off and on when we leave the house (by detecting presence of our mobile phone).</p>

<h1 id="concept">Concept</h1>

<p>We&rsquo;ll be checking if the mac-address of our phone is on the wifi network. Based on this we&rsquo;ll do a simple scheduling of our heating.</p>

<h1 id="home-assistant">Home assistant</h1>

<p>No python scripts this time, only activity is done in Home Assistant.</p>

<h2 id="device-tracking">Device tracking</h2>

<p>Example below will use the component <code>device_tracker</code> and the nmap program to scan the network.</p>

<pre><code>#NMAP is unreliable without scan_options
device_tracker:
  - platform: nmap_tracker
    hosts: 192.168.0.1-254
    consider_home: 600
    interval_seconds: 180
    scan_options: &quot; -min-rtt-timeout 3s &quot; #scan_options: &quot; -min-rtt-timeout 3s --privileged -sP &quot;
</code></pre>

<ul>
<li>it will scan all ip-addresses 192.168.0.x</li>
<li>an additional scan option has been added to increase the minimum timeout, detection on my wireless network does not seem to work reliably without this option.</li>
<li>starts a scan every 180 seconds</li>
</ul>

<h2 id="identify-phone">Identify phone</h2>

<p>When Home Assistant starts scanning:</p>

<ul>
<li>automatically new devices will start popping up in your user interface, easiest way is to go to the states overview:
<figure>
    <img src="/goosst/pictures/devicetracker.png" width="760"/> <figcaption>
            <h4>States device tracker</h4>
        </figcaption>
</figure>
</li>
<li>to check which ip address your phone has, you can look it up on the phone

<ul>
<li>in Android: Settings -&gt; About phone -&gt; Status</li>
<li>or disable and enable the wifi on your phone and see which ones gets the status away in your home assistant interface (requires more patience)</li>
</ul></li>
<li>in your folder <code>/home/homeassistant/.homeassistant</code> a file <code>known_devices.yaml</code> will list all discovered devices</li>

<li><p>give a more decent name to the address linked to your phone (e.g. phone Jane)</p>

<pre><code>5c_35_3b_70_05_29:
hide_if_away: false
icon:
mac: 5C:35:3B:70:05:29
name: phone Jane
picture:
track: true
</code></pre></li>

<li><p>You should disable tracking (<code>track:false</code>) for the devices you are not interested in</p></li>
</ul>

<h2 id="automate-heating-based-on-presence">Automate heating based on presence</h2>

<p>Examples below</p>

<ul>
<li><p>Set temperature setpoint low when phone went from home to not home:</p>

<pre><code>automation leaving_house:
alias: set temp low when leaving house
trigger:
platform: state
entity_id: device_tracker.5c_35_3b_70_05_29
from: 'home'
to: 'not_home'
action:
service: shell_command.set_temp_low
data:
  message: &quot;Jane left house: heating low&quot;
</code></pre></li>

<li><p>Set temperature setpoint high when phone is present and it&rsquo;s between 6:30 and 22:30.
Every five minutes a new check on the home status is done.</p>

<pre><code>automation at_home:
alias: set temp high when being home
trigger:
platform: time_pattern
minutes: '/5'
condition:
condition: and
conditions:
  - condition: time
    after: '06:30:00'
    before: '22:30:00'
  - condition: state
    entity_id: device_tracker.5c_35_3b_70_05_29
    state: 'home'
action:
service: shell_command.set_temp_high
data:
  message: &quot;Jane is home: heating high&quot;
</code></pre></li>
</ul>

<!-- <div align=center>
<SCRIPT charset="utf-8" type="text/javascript" src="//ws-eu.amazon-adsystem.com/widgets/q?rt=tf_mfw&ServiceVersion=20070822&MarketPlace=DE&ID=V20070822%2FDE%2Fgoosst-21%2F8001%2F33cbbdfe-5f25-411e-af19-105529c55218"> </SCRIPT> <NOSCRIPT><A rel="nofollow" HREF="//ws-eu.amazon-adsystem.com/widgets/q?rt=tf_mfw&ServiceVersion=20070822&MarketPlace=DE&ID=V20070822%2FDE%2Fgoosst-21%2F8001%2F33cbbdfe-5f25-411e-af19-105529c55218&Operation=NoScript">Amazon.de Widgets</A></NOSCRIPT>
</div>
 -->
]]></content>
		</item>
		
		<item>
			<title>Heating automation - read information</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_partiii/</link>
			<pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_partiii/</guid>
			<description>Intro In this part we&amp;rsquo;ll read parameters from our heater through the interface of Home Assistant and plot them in the UI.
Concept We&amp;rsquo;ll be (mis)using the mqtt protocol to send messages from the ebusd program to Home Assistant. This sending of messages will be done in a python script.
Again: in this way we can focus on making all the ebus related items running in python and we don&amp;rsquo;t have to deal with a custom Home Assistant syntax.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>In this part we&rsquo;ll read parameters from our heater through the interface of Home Assistant and plot them in the UI.</p>

<h1 id="concept">Concept</h1>

<p>We&rsquo;ll be (mis)using the mqtt protocol to send messages from the ebusd program to Home Assistant. This sending of messages will be done in a python script.</p>

<p>Again: in this way we can focus on making all the ebus related items running in python and we don&rsquo;t have to deal with a custom Home Assistant syntax. I personally prefer spending time learning python over learning a custom program specific language/syntax.</p>

<h2 id="python-script">Python script</h2>

<p>script below:</p>

<ul>
<li>queries the ebus for certain parameters (three temperatures in this example)</li>
<li>broadcasts them as an mqtt message, pay attention the messages generated in the python scripts (e.g. <code>sensor/thermostat/temperature</code>) match with the <code>state_topic</code> defined in the sensors (see next section)</li>

<li><p>store the script again in <code>/home/homeassistant/.homeassistant/python_scripts/</code></p>

<pre><code>import subprocess
#import time

#read temperature measured by thermostat
cp = subprocess.run([&quot;ebusctl read RoomTemp&quot;],shell=True,stdout=subprocess.PIPE)
cp_string=cp.stdout.decode('utf-8')
busread=cp_string[0:5]
msg1=&quot;mosquitto_pub -h localhost -t sensor/thermostat/temperature -u stijn -P mqtt -m &quot;
cp = subprocess.run([msg1+busread],shell=True,stdout=subprocess.PIPE)

# read temperature setpoint
cp = subprocess.run([&quot;ebusctl read DisplayedHc1RoomTempDesired&quot;],shell=True,stdout=subprocess.PIPE)
cp_string=cp.stdout.decode('utf-8')
#print(cp_string)
busread=cp_string[0:4]
#print(busread)
msg1=&quot;mosquitto_pub -h localhost -t sensor/thermostat/temperature_set -u stijn -P mqtt -m &quot;
cp = subprocess.run([msg1+busread],shell=True,stdout=subprocess.PIPE)

# read temperature flow heating
cp = subprocess.run([&quot;ebusctl read Hc1ActualFlowTempDesired&quot;],shell=True,stdout=subprocess.PIPE)
cp_string=cp.stdout.decode('utf-8')
#print(cp_string)
busread=cp_string[0:4]
#print(busread)
msg1=&quot;mosquitto_pub -h localhost -t sensor/thermostat/temperature_flowtemp -u stijn -P mqtt -m &quot;
cp = subprocess.run([msg1+busread],shell=True,stdout=subprocess.PIPE)


# read time
#cp = subprocess.run([&quot;ebusctl read Time&quot;],shell=True,stdout=subprocess.PIPE)
#cp_string=cp.stdout.decode('utf-8')
#time_read=cp_string[0:8]
#msg1=&quot;mosquitto_pub -h localhost -t sensor/thermostat/fubar -u stijn -P mqtt -m &quot;
#print(time_read)
#cp = subprocess.run([msg1+time_read],shell=True,stdout=subprocess.PIPE)
</code></pre></li>
</ul>

<h2 id="home-assistant">Home assistant</h2>

<p>Add the following mqtt sensors to <code>configuration.yaml</code>. This contains a username and password for the mqtt configuration (stored in <code>secrets.yaml</code>), for initial debugging you could consider removing username and password.</p>

<pre><code>mqtt:
  broker: 127.0.0.1
  username: stijn
  password: !secret pass_mqtt
  discovery: true

sensor:
  - platform: mqtt
    name: &quot;Temperature living&quot;
    state_topic: sensor/thermostat/temperature
    unit_of_measurement: &quot;°C&quot;
  - platform: mqtt
    name: &quot;Temperature setpoint living&quot;
    state_topic: sensor/thermostat/temperature_set
    unit_of_measurement: &quot;°C&quot;
  - platform: mqtt
    name: &quot;Temperature flow radiator&quot;
    state_topic: sensor/thermostat/temperature_flowtemp
    unit_of_measurement: &quot;°C&quot;
</code></pre>

<p>We&rsquo;ll create a <code>shell_command</code> to be able to call the python script above to read out the parameters on the ebus, we&rsquo;ll add a third item called <code>read_ebus</code> (<code>readtime_thermostat.py</code> is the script mentioned above).</p>

<p>In <code>configuration.yaml</code> it looks like this:</p>

<pre><code>shell_command:
  set_temp_high: python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature_on.py
  set_temp_low: python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature_off.py
  read_ebus: python3 /home/homeassistant/.homeassistant/python_scripts/readtime_thermostat.py
</code></pre>

<p>Now we will use a first automation to trigger a periodic reading of the ebus (if you don&rsquo;t want to do this in Home Assistant you could do this in python as well). Here we&rsquo;ll trigger a new reading every 7 minutes.</p>

<p>add to <code>configuration.yaml</code>:</p>

<pre><code>automation ebusreading:
  alias: read ebus
  trigger:
    platform: time_pattern
    minutes: '/7'
  action:
    service: shell_command.read_ebus
    data:
      message: &quot;thermostat reading&quot;
</code></pre>

<h2 id="home-assistant-ui">Home assistant UI</h2>

<p>You can see the three sensor values defined and reading out its value :).</p>

<figure>
    <img src="/goosst/pictures/sensorvalues2.png" width="760"/> <figcaption>
            <h4>Sensors from the thermostat and heater read through the ebus</h4>
        </figcaption>
</figure>


<p>To put it in some nice graphs so we can see data over a longer period we need to add this to <code>configuration.yaml</code>:</p>

<pre><code>history_graph:
  gr1:
    name: temperature living
    entities:
      - sensor.temperature_setpoint_living
      - sensor.temperature_living
    hours_to_show: 72
    refresh: 600
  gr2:
    name: temperature heater
    entities:
      - sensor.temperature_flow_radiator
    hours_to_show: 72
    refresh: 600
</code></pre>

<p>This results in something like this (pending how you arrange it):
<figure>
    <img src="/goosst/pictures/historygraph.png" width="760"/> <figcaption>
            <h4>Sensor values in a graph</h4>
        </figcaption>
</figure>
</p>

<h2 id="tip">Tip</h2>

<p>I prefer to edit the user interface by code as well (easier to backup/restore), this can be done by adding the following in <code>configuration.yaml</code></p>

<pre><code>lovelace:
  mode: yaml
</code></pre>

<p>and to create a file with the name <code>ui-lovelace.yaml</code> where you for example can add the following:</p>

<pre><code>title: My Awesome Home
views:
  - title: Verwarming
    cards:
      - type: glance
        title: temperaturen
        entities:
          - sensor.temperature_living
          - sensor.temperature_setpoint_living
      - type: history-graph
        title: 'living temperature'
        entities:
          - sensor.temperature_setpoint_living
          - sensor.temperature_living
        hours_to_show: 72
        refresh_interval: 600
      - type: history-graph
        title: 'heater setpunt'
        entities:
          - sensor.temperature_flow_radiator
        hours_to_show: 72
        refresh_interval: 600
</code></pre>

<p>Which results in:
<figure>
    <img src="/goosst/pictures/lovelace_ui.png" width="760"/> <figcaption>
            <h4>Interface define in ui-lovelace.yaml</h4>
        </figcaption>
</figure>
</p>

<!-- <div align=center>
<SCRIPT charset="utf-8" type="text/javascript" src="//ws-eu.amazon-adsystem.com/widgets/q?rt=tf_mfw&ServiceVersion=20070822&MarketPlace=DE&ID=V20070822%2FDE%2Fgoosst-21%2F8001%2F33cbbdfe-5f25-411e-af19-105529c55218"> </SCRIPT> <NOSCRIPT><A rel="nofollow" HREF="//ws-eu.amazon-adsystem.com/widgets/q?rt=tf_mfw&ServiceVersion=20070822&MarketPlace=DE&ID=V20070822%2FDE%2Fgoosst-21%2F8001%2F33cbbdfe-5f25-411e-af19-105529c55218&Operation=NoScript">Amazon.de Widgets</A></NOSCRIPT>
</div>
 -->
]]></content>
		</item>
		
		<item>
			<title>Heating automation - set temperatures</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_partii/</link>
			<pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_partii/</guid>
			<description>Intro In this part we&amp;rsquo;ll:
 preparing the host which will run Home Assistant set our requested room temperature through the interface of Home Assistant.  Preparing the host There is hassbian, hass.io, homme-assistant itself, &amp;hellip; as you see, not confusing at all :). I&amp;rsquo;m using a regular debian based system since at least I know ebusd works in a debian environment. I&amp;rsquo;m not familiar with docker (hass.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>

<h1 id="intro">Intro</h1>

<p>In this part we&rsquo;ll:</p>

<ul>
<li>preparing the host which will run Home Assistant</li>
<li>set our requested room temperature through the interface of Home Assistant.</li>
</ul>

<h1 id="preparing-the-host">Preparing the host</h1>

<p>There is hassbian, hass.io, homme-assistant itself, &hellip; as you see, not confusing at all :). I&rsquo;m using a regular debian based system since at least I know ebusd works in a debian environment. I&rsquo;m not familiar with docker (hass.io) and its limitations.</p>

<p>A detailed description to setup your host can be found <a href="/goosst/posts/hass_laptop/">here</a>.</p>

<h1 id="initial-temperature-test-using-home-assistant">Initial temperature test using Home Assistant</h1>

<p>It&rsquo;s time to get our heater commanded through Home Assistant.
In general it&rsquo;s good to:</p>

<ul>
<li>read a few intro&rsquo;s on Home Assistant before you jump in to it</li>
<li>get Samba up and running so you can edit your home assistant files from your standard working computer (again enough other tutorials can be found)</li>
</ul>

<h2 id="concept">Concept</h2>

<p>We&rsquo;ll be using python scripts to trigger actions from Home Assistant to ebus(d).
In this way we can focus on making all the ebus related items running in python and we don&rsquo;t have to deal with the custom Home Assistant syntax. I personally prefer spending time learning python over learning a custom program specific language/syntax.</p>

<h2 id="python-scripts">python scripts</h2>

<p>We&rsquo;ll create a few python scripts to test if we can control our heater from python. On the Pi we will create a new folder <code>python_scripts</code> locate the scripts in <code>/home/homeassistant/.homeassistant/python_scripts</code>.</p>

<ul>
<li>The script below with the name <code>set_temperature_on.py</code> will set the day and night temperatures to 21C by calling the appropriate ebus commands directly from the command line (making use of the subprocess function). The second part of the script just does an additional check if it was really set correctly.</li>

<li><p>create the same script with the name <code>set_temperature_off.py</code> where <code>msg2</code> in the script below has been changed to <code>msg2=15</code>. (Yes, I know this is a stupid way of working and we should give the temperature as an argument to the python script. But for initial testing/debugging this is good enough.)</p>

<pre><code>import subprocess
import time

msg2=&quot;21&quot; #setpoint temperature degrees celsius

msg1=&quot;ebusctl write -c f37 Hc1DayTemp &quot;
cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)

msg1=&quot;ebusctl write -c f37 Hc1NightTemp &quot;
cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)

#redundancy check if it is truly set
time.sleep(60)

cp = subprocess.run([&quot;ebusctl read Hc1DayTemp&quot;],shell=True,stdout=subprocess.PIPE)
temp=cp.stdout
if int(float(temp[0:4]))!=int(msg2):
# if not set correct
msg1=&quot;ebusctl write -c f37 Hc1DayTemp &quot;
cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)


cp = subprocess.run([&quot;ebusctl read Hc1NightTemp&quot;],shell=True,stdout=subprocess.PIPE)
temp=cp.stdout
if int(float(temp[0:4]))!=int(msg2):
# if not set correct
msg1=&quot;ebusctl write -c f37 Hc1NightTemp &quot;
cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)
else:
print(&quot;setting correct&quot;)
</code></pre></li>

<li><p>check if the scripts are really working by running the command from the raspberry pi terminal <code>python3 -i set_temperature_on.py</code></p>

<ul>
<li>as an additional check, on the thermostat you will see the temperature setting change
<figure>
    <img src="/goosst/pictures/heating_on.jpg" width="450"/> <figcaption>
            <h4>Python script has set temperature to 21 degrees!</h4>
        </figcaption>
</figure>
</li>
</ul></li>

<li><p>do the same for the script <code>python3 -i set_temperature_off.py</code>
<figure>
    <img src="/goosst/pictures/heating_off.jpg" width="450"/> <figcaption>
            <h4>Python script has set temperature to 15 degrees!</h4>
        </figcaption>
</figure>

Output in the terminal of the raspberry:</p>

<pre><code>pi@hassbian:/home/homeassistant/.homeassistant/python_scripts $ python3 -i set_temperature_on.py
setting correct
&gt;&gt;&gt; quit()
pi@hassbian:/home/homeassistant/.homeassistant/python_scripts $ python3 -i set_temperature_off.py
setting correct
&gt;&gt;&gt;

</code></pre></li>
</ul>

<h2 id="home-assistant-services">Home Assistant services</h2>

<p>Now this is working, we&rsquo;ll link it to Home Assistant.
If you&rsquo;ve followed Home Assistant intro&rsquo;s, you know all magic happens in the <code>configuration.yaml</code> file(s).
We&rsquo;ll be using the <code>shell_command</code> component which basically just executes a script in the terminal / command line of the raspberry.
Add the following into <code>configuration.yaml</code> and reload/reboot home assistant.</p>

<pre><code>shell_command:
  set_temp_high: python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature_on.py
  set_temp_low: python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature_off.py
</code></pre>

<p>From the Home Assistant interface:</p>

<ul>
<li>click on the services button in &ldquo;Developer tools&rdquo;</li>
<li>check the shell_command services</li>
<li>if you select the <code>set_temp_low</code> and <code>set_temp_high</code> and press &ldquo;call service&rdquo; the temperature will be set to 15 and 21 degrees :)</li>
</ul>

<figure>
    <img src="/goosst/pictures/HA_services2.png" width="500"/> <figcaption>
            <h4>Service becomes available in Home Assistant</h4>
        </figcaption>
</figure>


<h1 id="clean-up-method">Clean up method</h1>

<p>In the sections above, we&rsquo;ve demonstrated the basic functionallity of controlling the temperature requests. Next steps are:</p>

<ul>
<li>to provide the temperature as an argument from Home Assistant to the python script (instead of the hardcoded values from above)</li>
<li>get rid of seperate python scripts for each function (harder to maintain)</li>
<li>make sure not multiple people write at the same moment to the ebus (don&rsquo;t want to confuse our system)</li>
</ul>

<h2 id="adapt-python-scripts">Adapt python scripts</h2>

<p>Starting with the python scripts:</p>

<ul>
<li>We want to provide the temperature as argument to our python script (have <code>msg2</code> as an external input in our script)</li>

<li><p>We&rsquo;ll use the <code>getopt</code> module in python and parse the arguments to create a temp setpoint,</p>

<pre><code>import getopt

# check if passed options are valid
try:
options, args = getopt.getopt(sys.argv[1:], 't:',['temperature_setpoint='])
print(options)
print(args)
except getopt.GetoptError:
print(&quot;incorrect syntax&quot;)
print(&quot;usage: python3 set_temperature.py -t &lt;value&gt;&quot;)
print(&quot;default to 12 degrees&quot;)
msg2=12
sys.exit(2)
for opt, value in options:
if opt in ('-t','-T','--temperature_setpoint'):
    msg2=value
    print(&quot;successful argument&quot;)
    print(msg2)
</code></pre>

<ul>
<li>running the script in commandline becomes: <code>python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature.py -t 20.5</code></li>
</ul></li>
</ul>

<h2 id="user-interface">User interface</h2>

<p>In <code>configuration.yaml</code>, we&rsquo;ll define three input boxes for setting a temperature (night, day and an additional one for instant change of the heating).
The critical part are the additional <code>{{}}</code> arguments in the <code>shell_command</code> definition. The exact name of the argument you need to find back in the <code>states</code> menu in the user interface.</p>

<pre><code>
input_number:
  slider1:
    name: Set Now
    initial: 21
    min: 5
    max: 30
    step: 0.25
    unit_of_measurement: &quot;°C&quot;
  slider_night:
    name: Temp Night
    initial: 15
    min: 5
    max: 23
    step: 0.25
    unit_of_measurement: &quot;°C&quot;
  slider_day:
    name: Temp Day
    initial: 21
    min: 5
    max: 25
    step: 0.25
    unit_of_measurement: &quot;°C&quot;

shell_command:
  set_temp_high: 'python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature.py -t {{ states.input_number.slider_day.state }}'
  set_temp_low: 'python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature.py -t {{ states.input_number.slider_night.state }}'
  set_temp_living: 'python3 /home/homeassistant/.homeassistant/python_scripts/set_temperature.py -t {{ states.input_number.slider1.state }}'
</code></pre>

<p>In <code>ui-lovelace.yaml</code>, we&rsquo;ll define a card including our new three sliders.</p>

<pre><code>  - title: Verwarming
    cards:
      - type: entities
        title: temperaturen
        entities:
          - sensor.temperature_living
          - sensor.temperature_setpoint_living
          - input_number.slider_day
          - input_number.slider_night
          - input_number.slider1
</code></pre>

<h2 id="mutual-exclusion">Mutual exclusion</h2>

<ul>
<li>We&rsquo;ll be using the python module <code>ilock</code> to make sure not multiple instances write/read at the same time to the ebus</li>
<li>Installation <code>pi@hassbian:~ $ sudo pip3 install ilock</code>

<ul>
<li>the <code>sudo</code> here turns out to be important: <a href="https://community.home-assistant.io/t/shell-command-pi-versus-ha/114939/3">https://community.home-assistant.io/t/shell-command-pi-versus-ha/114939/3</a></li>
</ul></li>
</ul>

<p>The working code of the pythong script becomes:</p>

<pre><code>
import subprocess
import time
import getopt
import sys
from ilock import ILock

# check if passed options are valid
try:
    options, args = getopt.getopt(sys.argv[1:], 't:',['temperature_setpoint='])
    print(options)
    print(args)
except getopt.GetoptError:
    print(&quot;incorrect syntax&quot;)
    print(&quot;usage: python3 set_temperature.py -t &lt;value&gt;&quot;)
    print(&quot;default to 12 degrees&quot;)
    msg2=12
    sys.exit(2)
for opt, value in options:
    if opt in ('-t','-T','--temperature_setpoint'):
        msg2=value
        print(&quot;successful argument&quot;)
        print(msg2)

with ILock('ebus', timeout=200):
	msg1=&quot;ebusctl write -c f37 Hc1DayTemp &quot;
	cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)

	msg1=&quot;ebusctl write -c f37 Hc1NightTemp &quot;
	cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)

	time.sleep(30)

	#check if it is truly set
	cp = subprocess.run([&quot;ebusctl read Hc1DayTemp&quot;],shell=True,stdout=subprocess.PIPE)
	temp=cp.stdout
	if int(float(temp[0:4]))!=int(float(msg2)):
	    # if not set correct
	    msg1=&quot;ebusctl write -c f37 Hc1DayTemp &quot;
	    cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)

	cp = subprocess.run([&quot;ebusctl read Hc1NightTemp&quot;],shell=True,stdout=subprocess.PIPE)
	temp=cp.stdout
	if int(float(temp[0:4]))!=int(float(msg2)):
	    # if not set correct
	    msg1=&quot;ebusctl write -c f37 Hc1NightTemp &quot;
	    cp = subprocess.run([msg1+msg2],shell=True,stdout=subprocess.PIPE)
	else:
	    print(&quot;setting correct&quot;)
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>Heating automation - intro</title>
			<link>http://users.telenet.be/goosst/posts/homeautomation_intro/</link>
			<pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
			
			<guid>http://users.telenet.be/goosst/posts/homeautomation_intro/</guid>
			<description>Intro I think we all want a more intelligent control over our heaters than what the standard thermostats have to offer. e.g. Automatically turning the heating off when leaving your home, scheduling the heater to turn on sooner in the morning when it&amp;rsquo;s cold, &amp;hellip; .
Disregarding privacy concerns, commercial solutions like Google Nest only seem to support on/off control of the heating. If we want to use proportional/modulated heating for more comfort, at the time of writing the amount of solutions seems very limited.</description>
			<content type="html"><![CDATA[

<aside>
    
</aside>


<h1 id="intro">Intro</h1>

<p>I think we all want a more intelligent control over our heaters than what the standard thermostats have to offer. e.g. Automatically turning the heating off when leaving your home, scheduling the heater to turn on sooner in the morning when it&rsquo;s cold, &hellip; .</p>

<p>Disregarding privacy concerns, commercial solutions like Google Nest only seem to support on/off control of the heating. If we want to use proportional/modulated heating for more comfort, at the time of writing the amount of solutions seems very limited.</p>

<p>Luckily, the open-source world has done a massive amount of work related to home automation and understanding the protocols used by commercial heating systems. Despite all this work, it is a learning curve to find your way through all the different tools / programs and how to use them. When my system ever breaks down I want to have some documentation how I did everything again, so I&rsquo;ve made some documentation and made it public &hellip; .</p>

<h1 id="goal">Goal</h1>

<p>If your goal is to remove your thermostat completely, that&rsquo;s not going to happen in this blog.</p>

<p>The posts provide guidance how to add additional intelligence and monitoring to our setup and serve as documentation for myself and others. It&rsquo;s not a dummy proof step-by-step guide.</p>

<h1 id="tools">Tools</h1>

<p>We&rsquo;ll be using the following hardware and software:</p>

<ol>
<li>A debian based system (laptop, tinkerboard, <a href="https://www.banggood.com/Raspberry-Pi-3-Model-B-Plus-Mother-Board-Mainboard-With-BCM2837B0-Cortex-A53-ARMv8-1_4GHz-CPU-D-p-1278398.html?p=ET150713234951201708&amp;custlinkid=664885">Raspberry pi 3b</a>, &hellip;)</li>
<li>ebus adapter: <a href="https://ebus.github.io/adapter/index.en.html">https://ebus.github.io/adapter/index.en.html</a></li>
<li>ebusd software: <a href="https://github.com/john30/ebusd">https://github.com/john30/ebusd</a></li>
<li>Home Assistant: <a href="https://www.home-assistant.io/">https://www.home-assistant.io/</a></li>
</ol>

<p>Ebus is the communication protocol used by a lot of heating systems, we&rsquo;ll have to tap into this communication system to help our thermostat become more intelligent.</p>

<p>It&rsquo;s fair to say without the ebusd software this project would never have happened.</p>

<p>My latest files can be found here: <a href="https://github.com/goosst/HomeAutomation">https://github.com/goosst/HomeAutomation</a></p>

<h1 id="setup">Setup</h1>

<p>My setup is rather simple:</p>

<ol>
<li>Vaillant ecotec plus: heats one room</li>
<li>Wireless thermostat, Calormatic 370f</li>
</ol>

<p><figure>
    <img src="/goosst/pictures/IMG_20190420_091458.jpg" width="350"/> <figcaption>
            <h4>Vaillant ecotec plus</h4>
        </figcaption>
</figure>

<figure>
    <img src="/goosst/pictures/IMG_20190420_112454.jpg" width="350"/> <figcaption>
            <h4>Vaillant wireless thermostat, Calormatic 370f</h4>
        </figcaption>
</figure>
</p>

<h1 id="getting-started">Getting started</h1>

<ul>
<li><a href="/goosst/posts/homeautomation_wemos_ebus/">Hardware and communication to heater</a></li>
<li><a href="/goosst/posts/homeautomation_partii/">Set temperatures through Home Assistant</a></li>
<li><a href="/goosst/posts/homeautomation_partiii/">Reading additional information through Home Assistant</a></li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
